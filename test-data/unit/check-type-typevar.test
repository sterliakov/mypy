-- Test cases for type[SomeTypeVar] treatment


[case testTypeOfTypeVarInstantiation]
from typing import TypeVar, Type
T = TypeVar('T')
def f(x: Type[T]) -> T:
    return x()

[case testTypeOfTypeVarBoundInstantiationInitParams]
from typing import TypeVar, Type
class A:
    def __init__(self, x: str) -> None: pass
T = TypeVar('T', bound=A)
def f(x: Type[T]) -> T:
    return x('a')
def f2(x: Type[T]) -> T:
    return x(1)  # E: Argument 1 to "A" has incompatible type "int"; expected "str"

[case testTypeOfTypeVarBoundInstantiationGeneric]
from typing import Generic, TypeVar, Type
class A:
    def __init__(self, x: str) -> None: pass

T = TypeVar('T', bound=object)
V = TypeVar('V', bound=A)

class Test(Generic[T, V]):
    X: Type[T]
    Y: Type[V]
    def f1(self) -> T:
        return self.X()
    def f2(self) -> V:
        return self.Y()  # E: Missing positional argument "x" in call to "A"
    def f3(self) -> V:
        return self.Y(1)  # E: Argument 1 to "A" has incompatible type "int"; expected "str"
    def f4(self) -> V:
        return self.Y('foo')

[case testTypeOfTypeVarInstantiationInitParamsUnionBound]
from typing import TypeVar, Type, Union
class A:
    def __init__(self, x: str) -> None: pass
class B:
    def __init__(self, x: int) -> None: pass
class C:
    def __init__(self, x: int) -> None: pass

T = TypeVar('T', bound=Union[A, B])
def f(x: Type[T]) -> T:
    return x(1)  # E: Argument 1 to "A" has incompatible type "int"; expected "str"

T2 = TypeVar('T2', bound=Union[B, C])
def f2(x: Type[T2]) -> T2:
    return x(1)

[case testTypeOfTypeVarInstantiationVariants]
from typing import TypeVar, Type
class A:
    def __init__(self, x: str) -> None: pass
class B:
    def __init__(self, x: int) -> None: pass
class C:
    def __init__(self, x: int) -> None: pass

T = TypeVar('T', A, B)
def f(x: Type[T]) -> T:
    return x(1)  # E: Argument 1 to "A" has incompatible type "int"; expected "str"

T2 = TypeVar('T2', B, C)
def f2(x: Type[T2]) -> T2:
    return x(1)

def return_indirect(x: Type[T2]) -> T2:
    ret = x(1)
    return ret

def return_indirect_condition(x: Type[T2], flag: bool) -> T2:
    if flag:
        ret = x(1)
    else:
        ret = x(2)
    return ret

def return_indirect_condition_invalid(x: Type[T2], flag: bool) -> T2:
    if flag:
        ret = x(1)
    else:
        ret = x('foo')  # E: Argument 1 to "B" has incompatible type "str"; expected "int" \
                        # E: Argument 1 to "C" has incompatible type "str"; expected "int"
    return ret

def return_indirect_condition_invalid_different(x: Type[T], flag: bool) -> T:
    if flag:
        ret = x(1)  # E: Argument 1 to "A" has incompatible type "int"; expected "str"
    else:
        ret = x('foo')  # E: Argument 1 to "B" has incompatible type "str"; expected "int"
    return ret

[case testTypeOfTypeVarValuesStrictNarrowingImpossible]
from typing import TypeVar, Type, Union
class A:
    def __init__(self, x: str) -> None: pass
class B:
    def __init__(self, x: int) -> None: pass

T = TypeVar('T', A, B)

def return_narrowing(x: Type[T]) -> T:
    if issubclass(x, B):
        reveal_type(x) \
            # N: Revealed type is "Type[__main__.<subclass of "A" and "B">]" \
            # N: Revealed type is "Type[__main__.B]"
        return x(1)  # E: Argument 1 to <subclass of "A" and "B"> has incompatible type "int"; expected "str"
    else:
        reveal_type(x)  # N: Revealed type is "Type[__main__.A]"
        return x('foo')

def return_indirect_narrowing(x: Type[T]) -> T:
    ret: T
    if issubclass(x, B):
        reveal_type(x) \
            # N: Revealed type is "Type[__main__.<subclass of "A" and "B">1]" \
            # N: Revealed type is "Type[__main__.B]"
        ret = x(1)  # E: Argument 1 to <subclass of "A" and "B"> has incompatible type "int"; expected "str"
    else:
        reveal_type(x)  # N: Revealed type is "Type[__main__.A]"
        ret = x('foo')
    return ret
[builtins fixtures/isinstance.pyi]

[case testTypeOfTypeVarBoundStrictNarrowingImpossible]
from typing import TypeVar, Type, Union
class A:
    def __init__(self, x: str) -> None: pass
class B:
    def __init__(self, x: int) -> None: pass

T = TypeVar('T', bound=Union[A, B])

def return_narrowing(x: Type[T]) -> T:
    if issubclass(x, B):
        reveal_type(x)  # N: Revealed type is "Type[T`-1]"
        return x(1)
    else:
        reveal_type(x)  # N: Revealed type is "Type[T`-1]"
        return x('foo')

def return_indirect_narrowing(x: Type[T]) -> T:
    ret: T
    if issubclass(x, B):
        reveal_type(x)  # N: Revealed type is "Type[T`-1]"
        ret = x(1)
    else:
        reveal_type(x)  # N: Revealed type is "Type[T`-1]"
        ret = x('foo')
    return ret
[builtins fixtures/isinstance.pyi]

[case testTypeOfTypeVarValuesNarrowing]
from typing import TypeVar, Type
class A:
    x: str
    def __init__(self, x: str) -> None: pass
class B:
    x: int
    def __init__(self, x: int) -> None: pass

T = TypeVar('T', A, B)

def return_narrowing(x: Type[T]) -> T:
    if issubclass(x, B):
        reveal_type(x)  # N: Revealed type is "Type[__main__.B]"
        return x(1)
    else:
        reveal_type(x)  # N: Revealed type is "Type[__main__.A]"
        return x('foo')

def return_indirect_narrowing(x: Type[T]) -> T:
    ret: T
    if issubclass(x, B):
        reveal_type(x)  # N: Revealed type is "Type[__main__.B]"
        ret = x(1)
    else:
        reveal_type(x)  # N: Revealed type is "Type[__main__.A]"
        ret = x('foo')
    return ret
[builtins fixtures/isinstance.pyi]

[case testTypeOfTypeVarBoundNarrowing]
from typing import TypeVar, Type, Union
class A:
    x: str
    def __init__(self, x: str) -> None: pass
class B:
    x: int
    def __init__(self, x: int) -> None: pass

T = TypeVar('T', bound=Union[A, B])

def return_narrowing(x: Type[T]) -> T:
    if issubclass(x, B):
        reveal_type(x)  # N: Revealed type is "Type[T`-1]"
        return x(1)
    else:
        reveal_type(x)  # N: Revealed type is "Type[T`-1]"
        return x('foo')

def return_indirect_narrowing(x: Type[T]) -> T:
    ret: T
    if issubclass(x, B):
        reveal_type(x)  # N: Revealed type is "Type[T`-1]"
        ret = x(1)
    else:
        reveal_type(x)  # N: Revealed type is "Type[T`-1]"
        ret = x('foo')
    return ret
[builtins fixtures/isinstance.pyi]

[case testTypeOfTypeVarBoundThreeNarrowing]
from typing import TypeVar, Type, Union
class A:
    x: str
    def __init__(self, x: str) -> None: pass
class B:
    x: int
    def __init__(self, x: int) -> None: pass
class C:
    x: bool
    def __init__(self, x: int) -> None: pass

T = TypeVar('T', bound=Union[A, B, C])

def return_narrowing(x: Type[T]) -> T:
    if issubclass(x, B):
        reveal_type(x)  # N: Revealed type is "Type[T`-1]"
        return x(1)
    elif issubclass(x, C):
        reveal_type(x)  # N: Revealed type is "Type[T`-1]"
        return x(True)
    else:
        reveal_type(x)  # N: Revealed type is "Type[T`-1]"
        return x('foo')

def return_narrowing_compatible(x: Type[T]) -> T:
    if issubclass(x, (B, C)):
        reveal_type(x)  # N: Revealed type is "Type[T`-1]"
        return x(True)
    else:
        reveal_type(x)  # N: Revealed type is "Type[T`-1]"
        return x('foo')
[builtins fixtures/isinstance.pyi]
